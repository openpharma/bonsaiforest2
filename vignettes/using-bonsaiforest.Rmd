---
title: "Using bonsai forest for Bayesian Subgroup Analysis"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using bonsai forest for Bayesian Subgroup Analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5,
  eval = FALSE # Set eval=TRUE when actually building vignette in package
)
```

## Introduction

Welcome to the `bonsaiforest2` package! ðŸŒ³ Its main goal is to make it easier to fit and interpret **Bayesian models for subgroup analysis** in clinical trials using the powerful `brms` package in the background.

`bonsaiforest2` helps you:

-   Distinguish between **prognostic** (baseline outcome predictors) and **predictive** (treatment effect modifiers) variables.
-   Apply different **shrinkage priors** to different sets of coefficients, allowing for robust exploration of subgroup effects while controlling for false positives.
-   Calculate interpretable **marginal treatment effects** for each subgroup.
-   **Visualize** the results using forest plots.

This vignette will guide you through the **main workflow** using the primary functions:

1.  `run_brms_analysis()`: Prepares the model formula and fits the `brms` model.
2.  `summary_subgroup_effects()`: Calculates the marginal overall and subgroup treatment effects from the fitted model.
3.  `plot()`: Creates a forest plot from the summary object.

Let's get started!

## Setup

First, let's load the necessary packages. Make sure you have `bonsaiforest2`, `brms`, `survival`, `dplyr`, and `ggplot2` installed.

```{r load-packages, eval=TRUE}
# Load the main package
library(bonsaiforest2)

# Load other required packages for examples
library(brms)
library(survival)
library(dplyr)
library(ggplot2)
```

## Core Workflow Functions

The package follows a simple workflow: **Specify & Fit -\> Summarize -\> Plot**.

### 1. `run_brms_analysis()`

This is your main workhorse function for setting up and fitting the model. You provide your data and define different parts of the model using formula strings.

**Key Arguments:**

-   `data`: Your input `data.frame`.
-   `response_formula_str`: Defines the outcome and main treatment effect (e.g., `"outcome ~ trt"`).
-   `response_type`: `"continuous"`, `"binary"`, `"count"`, or `"survival"`.
-   `unshrunk_prognostic_formula_str`: Main effects (not treatment interactions) to estimate without strong shrinkage (e.g., `"~ age"`).
-   `shrunk_prognostic_formula_str`: Main effects to estimate with shrinkage.
-   `unshrunk_predictive_formula_str`: Treatment interactions to estimate without strong shrinkage (e.g., `"~ prespecified_marker:trt"`).
-   `shrunk_predictive_formula_str`: Treatment interactions to estimate with shrinkage (e.g., `"~ region:trt + sex:trt"`). Often used for exploratory subgroups.
-   `prognostic_effect_priors`, `predictive_effect_priors`: Lists specifying priors for shrunk/unshrunk terms (see next section).
-   `stanvars`: Optional object from `brms::stanvar()` for custom Stan code (e.g., for hierarchical priors).
-   `...`: Other arguments passed directly to `brms::brm()` (like `chains`, `iter`, `cores`).

This function internally calls `prepare_formula_model` to build the complex `brmsformula` and process the data (like creating dummy variables for interactions) and then calls `fit_brms_model` to run the MCMC sampling.

### 2. `summary_subgroup_effects()`

Once you have a fitted model from `run_brms_analysis`, this function calculates the key results: **marginal subgroup treatment effects**.

**Key Arguments:**

-   `brms_fit`: The fitted model object from `run_brms_analysis`.
-   `original_data`: The *original* `data.frame` you passed to `run_brms_analysis`. This is crucial for correctly identifying subgroup levels.
-   `trt_var`: The name of the treatment variable (string).
-   `subgroup_vars`: Which subgroups to analyze. Can be:
    -   `"auto"` (default): Automatically finds subgroups based on interaction terms in the model.
    -   `NULL`: Calculates only the overall marginal effect.
    -   A character vector (e.g., `c("region", "sex")`): Calculates effects for the specified variables.
-   `response_type`: Must match the type used for fitting.

This function uses a **counterfactual approach (G-computation)** to estimate average effects for each subgroup, integrating over the distribution of other covariates within that subgroup. It returns a special `subgroup_summary` object.

### 3. `plot()`

This function takes the `subgroup_summary` object and generates a forest plot.

**Usage:**

```{r, eval=FALSE }
# Assuming 'my_summary' is output from summary_subgroup_effects()
plot(my_summary, title = "My Forest Plot", x_lab = "Effect Measure (e.g., AHR)")
```

It automatically arranges the subgroups, adds reference lines, and formats the estimates with credible intervals.



## Specifying Priors

You can control the priors used for the different model components via the `prognostic_effect_priors` and `predictive_effect_priors` arguments in `fit_brms_model`.

  * `predictive_effect_priors` expects a named list like `list(shrunk = ..., unshrunk = ...)`.
  * `prognostic_effect_priors` expects a named list like `list(shrunk = ..., unshrunk = ..., intercept = ...)`.
  

### Prior Formats

You can provide priors in several formats:

  * **`NULL` (Default):** If you provide `NULL` or omit an argument, the function's built-in defaults are used.
  * **Simple Strings:** You can provide standard `brms` prior strings (e.g., `"normal(0, 1)"`).
  * **Advanced Priors:** You can use strings for advanced priors like `"R2D2(mean_R2 = 0.5, prec_R2 = 1)"` or provide full `brmsprior` objects (e.g., for custom hierarchical structures using `stanvars`).


### Default Priors

If priors are not specified, the function applies the following defaults (as defined in the `fit_brms_model` code):

  * **Prognostic Shrunk:** `horseshoe(1)`
  * **Prognostic Unshrunk:** `normal(0, 5)`
  * **Prognostic Intercept:** `normal(0, 10)`
  * **Predictive Shrunk:** `horseshoe(1)`
  * **Predictive Unshrunk:** `normal(0, 5)`

**Note:** The intercept prior is *not* applied for `response_type = "survival"`, as Cox models do not have a global intercept.


### Prior Recommendations for non-shrunk terms

While the defaults are sensible, for continuous outcomes, we recommend setting weakly informative priors scaled to your data. A common approach is to base priors on the standard deviation (SD) of the outcome variable.

For example, if you pre-calculate `my_sd <- sd(my_data$outcome)`:

  * **Prognostic Intercept:** We recommend a wide prior, such as `normal(0, 10 * my_sd)`.
  * **Prognostic Unshrunk:** We recommend a prior scaled to the outcome, such as `normal(0, my_sd)`.

You can implement this as shown in **Example 3** below.

For a detailed explanation of shrinkage priors (Horseshoe, R2D2), see the 'Technical Details' vignette (`vignette('technical-details', package = 'bonsaiforest2')`).


Here are some examples of how to set priors:

```{r}
# Assume 'f' is a brmsformula and 'd' is a data.frame from prepare_formula_model

# Example 1: Use default priors
# (horseshoe for shrunk, normal(0, 5)/normal(0, 10) for unshrunk)
fit <- fit_brms_model(
  formula = f, data = d, ...,
  predictive_effect_priors = NULL, # Or omit
  prognostic_effect_priors = NULL  # Or omit
)

# Example 2: Specify all priors using strings
# This example clearly shows the new 'intercept' argument
fit <- fit_brms_model(
  formula = f, data = d, ...,
  predictive_effect_priors = list(
    shrunk = "student_t(3, 0, 2.5)",
    unshrunk = "normal(0, 5)"
  ),
  prognostic_effect_priors = list(
    shrunk = "lasso(1)",
    unshrunk = "normal(0, 10)",
    intercept = "student_t(3, 0, 10)" 
  )
)

# Example 3: Use recommended weakly informative priors (e.g., for continuous outcome)
# 1. Pre-calculate the standard deviation of the outcome
my_sd <- sd(d$my_outcome_variable) 

# 2. Create prior strings based on the SD
intercept_prior_str <- paste0("normal(0, ", round(10 * my_sd, 2), ")")
unshrunk_prior_str  <- paste0("normal(0, ", round(my_sd, 2), ")")

# 3. Pass these strings to the function
fit <- fit_brms_model(
  formula = f, data = d, ...,
  prognostic_effect_priors = list(
    shrunk = "horseshoe(1)",         # Keep shrinkage prior
    unshrunk = unshrunk_prior_str,    # Use scaled prior
    intercept = intercept_prior_str   # Use wide, scaled prior
  )
  # predictive_effect_priors will use defaults
)


# Example 4: Use R2D2 prior for shrunk predictive effects
r2d2_prior_string <- "R2D2(mean_R2 = 0.5, prec_R2 = 1)"
fit <- fit_brms_model(
  formula = f, data = d, ...,
  predictive_effect_priors = list(shrunk = r2d2_prior_string)
  # prognostic_effect_priors and unshrunk predictive will use defaults
)

# Example 5: Custom hierarchical prior using stanvars
# This is an advanced use case for defining a new hyperparameter 'tau_pred'
# and setting a prior on it, which is then shared by the shrunk predictive effects.

# 1. Define the hyperparameter 'tau_pred' for the Stan code
stanvars_pred <- stanvar(scode = "  real<lower=0> tau_pred;", block = "parameters")

# 2. Define the prior object using Stan code snippets
#    - Places a normal(0, tau_pred) prior on the b_shpredeffect vector
#    - Places a half-normal(0, 1) prior on tau_pred itself
hierarchical_prior_pred <-
  set_prior("target += normal_lpdf(b_shpredeffect | 0, tau_pred)", check = FALSE) +
  set_prior("target += normal_lpdf(tau_pred | 0, 1) - normal_lccdf(0 | 0, 1);", check = FALSE)

# 3. Pass both objects to the function
fit <- fit_brms_model(
  formula = f, data = d, ...,
  predictive_effect_priors = list(shrunk = hierarchical_prior_pred),
  stanvars = stanvars_pred
)
```

## Practical Examples

Let's walk through some examples using simulated data. *(Note: `iter` is kept low for speed; use more iterations for real analyses!)*

### Example 1: Continuous Outcome (Blood Pressure)

*Scenario*: Modeling change in Systolic Blood Pressure (SBP). Adjust for `baseline_sbp` (unshrunk) and explore interactions with `region` and `comorbidity` (shrunk).

```{r ex1-data}
set.seed(123)
n_patients <- 200
continuous_data <- data.frame(
  id = 1:n_patients,
  sbp_change = rnorm(n_patients, mean = -5, sd = 10),
  trt = sample(0:1, n_patients, replace = TRUE),
  baseline_sbp = rnorm(n_patients, mean = 140, sd = 15),
  region = factor(sample(c("NA", "EU", "APAC"), n_patients, replace = TRUE)),
  comorbidity = factor(sample(c("Yes", "No"), n_patients, replace = TRUE, prob = c(0.4, 0.6)))
)
# Ensure trt is a factor before passing to run_brms_analysis
continuous_data$trt <- factor(continuous_data$trt, levels = c(0, 1))
```

```{r ex1-fit}
continuous_model_fit <- run_brms_analysis(
  data = continuous_data,
  response_formula_str = "sbp_change ~ trt",
  response_type = "continuous",
  unshrunk_prognostic_formula_str = "~ baseline_sbp",
  # Shrink intercept (1), region interaction, and comorbidity interaction
  shrunk_predictive_formula_str = "~ 1 + region:trt + comorbidity:trt",
  chains = 1, iter = 200, warmup = 100, cores = 1, # Minimal settings for vignette
  refresh = 0, backend = "cmdstanr" # Use cmdstanr if available
)
# print(continuous_model_fit) # Optional: view raw brms fit
```

```{r ex1-summary-plot}
continuous_summary <- summary_subgroup_effects(
  brms_fit = continuous_model_fit,
  original_data = continuous_data, # Pass the original data
  trt_var = "trt",
  response_type = "continuous" # Must match fitting
  # subgroup_vars = "auto" is the default
)

# Print the summary table
print(continuous_summary$estimates)

# Generate and display the plot
plot(continuous_summary, title = "Continuous: Subgroup Effects on SBP Change")
```

### Example 2: Binary Outcome (Patient Remission)

*Scenario*: Modeling remission (0/1). Pre-specified interaction with `genetic_marker` (unshrunk), adjust for `age` and `disease_duration` (shrunk).

```{r ex2-data}
set.seed(456)
n_patients <- 300
binary_data <- data.frame(
  remission = rbinom(n_patients, 1, prob = 0.4),
  therapy = sample(0:1, n_patients, replace = TRUE),
  genetic_marker = factor(sample(c("Positive", "Negative"), n_patients, replace = TRUE)),
  age = rnorm(n_patients, 55, 8),
  disease_duration = rnorm(n_patients, 5, 2)
)
binary_data$therapy <- factor(binary_data$therapy, levels = c(0, 1))
```

```{r ex2-fit}
binary_model_fit <- run_brms_analysis(
  data = binary_data,
  response_formula_str = "remission ~ therapy",
  response_type = "binary",
  shrunk_prognostic_formula_str = "~ age + disease_duration",
  unshrunk_predictive_formula_str = "~ genetic_marker:therapy", # Focus interaction
  # Specify priors: horseshoe for shrunk prog, student_t for unshrunk pred
  prognostic_effect_priors = list(shrunk = "horseshoe(1)"),
  predictive_effect_priors = list(unshrunk = "student_t(3, 0, 2.5)"),
  chains = 1, iter = 200, warmup = 100, cores = 1, refresh = 0, backend = "cmdstanr"
)
```

```{r ex2-summary-plot}
binary_summary <- summary_subgroup_effects(
  brms_fit = binary_model_fit,
  original_data = binary_data,
  trt_var = "therapy",
  response_type = "binary"
)

print(binary_summary$estimates)
plot(binary_summary, title = "Binary: Subgroup Effects on Remission")
```

### Example 3: Count Outcome (Disease Exacerbations)

*Scenario*: Modeling exacerbation counts. Adjust for `baseline_severity` (unshrunk) and many exploratory `biomarkers` (shrunk). No interaction terms.

```{r ex3-data}
set.seed(789)
n_patients <- 150
biomarker_data <- as.data.frame(matrix(rnorm(n_patients * 10), ncol = 10))
names(biomarker_data) <- paste0("biomarker_", 1:10)
count_data <- data.frame(
  exacerbation_count = rnbinom(n_patients, size = 1.5, mu = 3),
  medication = sample(0:1, n_patients, replace = TRUE),
  baseline_severity = rnorm(n_patients, 10, 2),
  log_exposure_time = log(runif(n_patients, 0.5, 1.5)) # Example offset
)
count_data <- cbind(count_data, biomarker_data)
count_data$medication <- factor(count_data$medication, levels = c(0, 1))
```

```{r ex3-fit}
# Create formula string for all biomarkers
shrunk_prog_str <- paste("~", paste(names(biomarker_data), collapse = " + "))

count_model_fit <- run_brms_analysis(
  data = count_data,
  # Include offset in response formula
  response_formula_str = "exacerbation_count + offset(log_exposure_time) ~ medication",
  response_type = "count",
  unshrunk_prognostic_formula_str = "~ 1 + baseline_severity", # Intercept included here
  shrunk_prognostic_formula_str = shrunk_prog_str,
  chains = 1, iter = 200, warmup = 100, cores = 1, refresh = 0, backend = "cmdstanr"
)
```

```{r ex3-summary-plot}
count_summary <- summary_subgroup_effects(
  brms_fit = count_model_fit,
  original_data = count_data,
  trt_var = "medication",
  response_type = "count"
  # subgroup_vars = "auto" will correctly find no subgroups
)

print(count_summary$estimates) # Should only show "Overall"
plot(count_summary, title = "Count: Overall Effect on Exacerbations")
```

### Example 4: Survival Outcome (Time-to-Event)

*Scenario*: Oncology trial modeling time-to-event. Explore interaction with `ecog_status` using shrinkage.

```{r ex4-data}
set.seed(101)
n_patients <- 250
survival_data <- data.frame(
  survival_time = rexp(n_patients, rate = 0.1),
  event_status = rbinom(n_patients, 1, prob = 0.8),
  cancer_drug = sample(0:1, n_patients, replace = TRUE),
  ecog_status = factor(sample(0:2, n_patients, replace = TRUE)) # ECOG 0, 1, 2
)
survival_data$cancer_drug <- factor(survival_data$cancer_drug, levels = c(0, 1))
```

```{r ex4-fit}
survival_model_fit <- run_brms_analysis(
  data = survival_data,
  response_formula_str = "Surv(survival_time, event_status) ~ cancer_drug",
  response_type = "survival",
  shrunk_predictive_formula_str = "~ ecog_status:cancer_drug",
  chains = 1, iter = 200, warmup = 100, cores = 1, refresh = 0, backend = "cmdstanr"
)
```

```{r ex4-summary-plot}
survival_summary <- summary_subgroup_effects(
  brms_fit = survival_model_fit,
  original_data = survival_data,
  trt_var = "cancer_drug",
  response_type = "survival"
)

print(survival_summary$estimates)
plot(survival_summary, title = "Survival: Subgroup Effects (AHR)")
```

### Example 5: Stratified Continuous Model

*Scenario*: Modeling SBP change where variance differs by `clinic_site`. We stratify `sigma`. Also explore interaction with `age_group`.

```{r ex5-data}
set.seed(42)
n_patients <- 180
sigma_by_site <- c(SiteA = 6, SiteB = 12, SiteC = 18)
sample_data_strat_cont <- data.frame(
    id = 1:n_patients,
    clinic_site = factor(sample(c("SiteA", "SiteB", "SiteC"), n_patients, replace = TRUE))
)
sample_data_strat_cont$trt <- factor(sample(0:1, n_patients, replace = TRUE, prob = c(0.5, 0.5)))
sample_data_strat_cont$baseline_sbp <- rnorm(n_patients, mean = 145, sd = 8)
sample_data_strat_cont$age_group <- factor(sample(c("Under60", "Over60"), n_patients, replace = TRUE))
noise <- rnorm(n_patients, mean = 0, sd = sigma_by_site[sample_data_strat_cont$clinic_site])
sample_data_strat_cont$sbp_change <- -5 - (as.integer(sample_data_strat_cont$trt)-1) * 8 -
                                     0.2 * (sample_data_strat_cont$baseline_sbp - 145) +
                                     (as.integer(sample_data_strat_cont$trt)-1) * ifelse(sample_data_strat_cont$age_group == "Over60", -5, 0) +
                                     noise
```

```{r ex5-fit}
fit_continuous_stratified <- run_brms_analysis(
  data = sample_data_strat_cont,
  response_formula_str = "sbp_change ~ trt",
  response_type = "continuous",
  unshrunk_prognostic_formula_str = "~ baseline_sbp",
  shrunk_predictive_formula_str = "~ age_group:trt",
  stratification_formula_str = "~ clinic_site", # Stratify sigma by site
  chains = 1, iter = 200, warmup = 100, cores = 1, refresh = 0, backend = "cmdstanr"
)
```

```{r ex5-summary-plot}
strat_continuous_summary <- summary_subgroup_effects(
  brms_fit = fit_continuous_stratified,
  original_data = sample_data_strat_cont,
  trt_var = "trt",
  response_type = "continuous" # Auto-detects age_group interaction
)

print(strat_continuous_summary$estimates)
plot(strat_continuous_summary, title = "Stratified Continuous: Subgroup Effects")
```

### Example 6: Stratified Survival Model

*Scenario*: Modeling time-to-event where baseline hazard differs by `country`. We stratify the baseline hazard (`bhaz`). Explore interaction with `biomarker`.

```{r ex6-data}
set.seed(123)
n_patients <- 200
lambda_by_country <- c(US = 0.01, EU = 0.03)
surv_data_strat <- data.frame(
    id = 1:n_patients,
    country = factor(sample(c("US", "EU"), n_patients, replace = TRUE)),
    trt = factor(sample(0:1, n_patients, replace = TRUE)),
    age = rnorm(n_patients, 65, 10),
    biomarker = factor(sample(c("Low", "High"), n_patients, replace = TRUE))
)
lp <- (as.integer(surv_data_strat$trt)-1) * -0.6 + (surv_data_strat$age - 65) * 0.03 +
      (as.integer(surv_data_strat$trt)-1) * (as.integer(surv_data_strat$biomarker) - 1) * -0.5
u <- runif(n_patients)
lambda_vec <- lambda_by_country[surv_data_strat$country]
gamma <- 1.5 # Weibull shape parameter
true_event_time <- (-log(u) / (lambda_vec * exp(lp)))^(1/gamma)
censoring_time <- 60 # Administrative censoring time
surv_data_strat$event_status <- ifelse(true_event_time <= censoring_time, 1, 0)
surv_data_strat$event_time <- pmin(true_event_time, censoring_time)
```

```{r ex6-fit}
fit_surv_stratified <- run_brms_analysis(
  data = surv_data_strat,
  response_formula_str = "Surv(event_time, event_status) ~ trt",
  response_type = "survival",
  unshrunk_prognostic_formula_str = "~ age",
  shrunk_predictive_formula_str = "~ biomarker:trt",
  stratification_formula_str = "~ country", # Stratify baseline hazard
  chains = 1, iter = 200, warmup = 100, cores = 1, refresh = 0, backend = "cmdstanr"
)
```

```{r ex6-summary-plot}
strat_surv_summary <- summary_subgroup_effects(
  brms_fit = fit_surv_stratified,
  original_data = surv_data_strat,
  trt_var = "trt",
  response_type = "survival" # Auto-detects biomarker interaction
)

print(strat_surv_summary$estimates)
plot(strat_surv_summary, title = "Stratified Survival: Subgroup Effects (AHR)")
```

---
title: "Truth"
output: html_document
---

# Calculate "Truth" for All 4 Endpoints

- TTE: Empirical truth (via simulation)
- Binary, Count, Continuous: Theoretical truth (from coefficients)

SAVING: Saves a single "truth.RData" file into each endpoint's Scenarios folder.


## --- 1. LIBRARIES & SETUP ---
```{r}
library(survival)
library(tidyverse) # For piping and dplyr
library(checkmate) # For assertions
library(MASS)      # For mvrnorm (in simul_covariates)
library(broom)     # For tidy()
library(bonsaiforest)

# This script assumes ALL simulation functions are loaded:
source('functions.R')

RNGkind('Mersenne-Twister')
set.seed(0) # For reproducibility
```

## --- 2. PARAMETERS AND CONTAINERS ---
```{r}
# Select endpoints to run
all_endpoints <- c("tte", "binary", "count", "continuous")
all_scenarios <- as.character(1:6)

# TTE Model formulas
base_model_tte <- Surv(tt_pfs, ev_pfs) ~ arm
subgroup_model <- ~ x_1 + x_2 + x_3 + x_4 + x_5 + x_6 + x_7 + x_8 + x_9 + x_10

# Subgroup Definitions
# Standard subgroups (x_1 to x_10) - 25 total subgroups
# Used for TTE endpoint
subgroup_names <- c(
  "x_1.a", "x_1.b", "x_2.a", "x_2.b", "x_3.a", "x_3.b", "x_4.a",
  "x_4.b", "x_4.c", "x_5.a", "x_5.b", "x_5.c", "x_5.d", "x_6.a",
  "x_6.b", "x_7.a", "x_7.b", "x_8.a", "x_8.b", "x_8.c", "x_9.a",
  "x_9.b", "x_10.a", "x_10.b", "x_10.c"
)

# For non-TTE endpoints, use all subgroups (x_1 to x_10) to match data generation
# Same as subgroup_names, but kept as separate variable for clarity
subgroup_names_short <- subgroup_names

# Scenario 6 Interaction subgroups
scen_6_subgroups <- c("x_1_2.aa", "x_1_2.ab", "x_1_2.ba", "x_1_2.bb")

# Simulation Settings
n_repetitions <- 10       # Number of large simulations to average over
inflation_factor <- 1000  # Multiplier for N (1000 * 1000 = 1 Million patients)
t_quantile <- 0.95        # For TTE AHR calculation

# Helper to parse "x_1.a" into variable "x_1" and level "a"
get_subgroup_filter <- function(sg_name) {
  parts <- strsplit(sg_name, "\\.")[[1]]
  list(var = parts[1], lvl = parts[2])
}

# Helper to fit marginal models for non-TTE endpoints
fit_marginal_model <- function(data, endpoint) {
  if (endpoint == "binary") {
    # Log-Odds Ratio
    fit <- glm(y ~ arm, data = data, family = binomial(link = "logit"))
    return(coef(fit)["arm1"])
  } else if (endpoint == "count") {
    # Log-Rate Ratio - use Negative Binomial to match data generation and estimators
    fit <- tryCatch({
      MASS::glm.nb(y ~ arm, data = data)
    }, error = function(e) {
      # Fallback to Poisson if glm.nb fails (rare, but possible with small subgroups)
      warning("glm.nb failed, using Poisson GLM as fallback")
      glm(y ~ arm, data = data, family = poisson(link = "log"))
    })
    return(coef(fit)["arm1"])
  } else if (endpoint == "continuous") {
    # Mean Difference
    fit <- lm(y ~ arm, data = data)
    return(coef(fit)["arm1"])
  }
}
```

## --- 3. MAIN CALCULATION LOOP ---
```{r}
for (ep in all_endpoints) {
  
  # ========================================================
  # BRANCH A: TIME-TO-EVENT (Existing Logic)
  # ========================================================
  if (ep == "tte") {
    
    message(paste("ðŸš€ Calculating TTE Truth (Empirical) for", n_repetitions, "reps..."))
    
    # Initialize result frames
    true_overall_results <- init_data_frame(all_scenarios, c("HR", "AHR", "median_C", "median_I"))
    true_subgroup_hr <- init_data_frame(all_scenarios, subgroup_names)
    true_subgroup_ahr <- init_data_frame(all_scenarios, subgroup_names)
    true_ia_subgroup_hr <- init_data_frame(all_scenarios[6], scen_6_subgroups)
    true_ia_subgroup_ahr <- init_data_frame(all_scenarios[6], scen_6_subgroups)
    
    for (scenario in all_scenarios) {
      message(paste("   ...Scenario", scenario))
      
      # Matrices to store repetitions
      all_overall_results <- matrix(nrow = 4, ncol = n_repetitions)
      all_subgroups_log_hr <- matrix(nrow = length(subgroup_names), ncol = n_repetitions)
      all_subgroups_log_ahr <- matrix(nrow = length(subgroup_names), ncol = n_repetitions)
      
      if (scenario == "6") {
        ia_subgroups_log_hr <- matrix(nrow = length(scen_6_subgroups), ncol = n_repetitions)
        ia_subgroups_log_ahr <- matrix(nrow = length(scen_6_subgroups), ncol = n_repetitions)
      }
      
      for (j in seq_len(n_repetitions)) {
        # Simulate TTE Data
        sim_data <- simul_scenario(
          scenario = scenario, n_datasets = 1, inflation_factor = inflation_factor, add_uncensored_pfs = TRUE
        )[[1]]
        sim_data$arm <- factor(sim_data$arm)
        
        # 1. Overall
        all_overall_results[1, j] <- coxph(base_model_tte, data = sim_data)$coef
        all_overall_results[2, j] <- log(ahr_from_km("tt_pfs", "arm", sim_data, "ev_pfs", t_quantile))
        all_overall_results[3, j] <- median(sim_data$tt_pfs_uncens[sim_data$arm == "0"])
        all_overall_results[4, j] <- median(sim_data$tt_pfs_uncens[sim_data$arm == "1"])
        
        # 2. Subgroups (Using existing stacking logic)
        stacked_data <- generate_stacked_data(base_model_tte, subgroup_model, sim_data, resptype = "survival")
        
        naive_estimates <- stacked_data %>%
          group_by(subgroup) %>%
          do(tidy(coxph(Surv(time, status) ~ arm, data = .))) %>%
          filter(term == "arm1")
        
        all_subgroups_log_hr[, j] <- naive_estimates$estimate[match(subgroup_names, naive_estimates$subgroup)]
        
        # AHR Calculation
        for (k in seq_along(subgroup_names)) {
          ds_k <- subset(stacked_data, subgroup == subgroup_names[k])
          if (nrow(ds_k) > 0 && length(unique(ds_k$arm)) == 2) {
            all_subgroups_log_ahr[k, j] <- log(ahr_from_km("time", "arm", ds_k, "status", t_quantile))
          }
        }
        
        # 3. Scenario 6 Interactions
        if (scenario == "6") {
          sim_data$x_1_2 <- factor(paste0(sim_data$x_1, sim_data$x_2))
          stacked_ia <- generate_stacked_data(base_model_tte, ~x_1_2, sim_data, resptype = "survival")
          
          naive_ia <- stacked_ia %>%
            group_by(subgroup) %>%
            do(tidy(coxph(Surv(time, status) ~ arm, data = .))) %>%
            filter(term == "arm1")
          
          ia_subgroups_log_hr[, j] <- naive_ia$estimate[match(scen_6_subgroups, naive_ia$subgroup)]
          
          for (k in seq_along(scen_6_subgroups)) {
            ds_k <- subset(stacked_ia, subgroup == scen_6_subgroups[k])
            if (nrow(ds_k) > 0 && length(unique(ds_k$arm)) == 2) {
              ia_subgroups_log_ahr[k, j] <- log(ahr_from_km("time", "arm", ds_k, "status", t_quantile))
            }
          }
        }
      } 
      
      # Averaging results over repetitions
      true_overall_results[scenario, "HR"] <- exp(mean(all_overall_results[1, ], na.rm = TRUE))
      true_overall_results[scenario, "AHR"] <- exp(mean(all_overall_results[2, ], na.rm = TRUE))
      true_overall_results[scenario, "median_C"] <- mean(all_overall_results[3, ], na.rm = TRUE)
      true_overall_results[scenario, "median_I"] <- mean(all_overall_results[4, ], na.rm = TRUE)
      
      true_subgroup_hr[scenario, ] <- exp(apply(all_subgroups_log_hr, 1, mean, na.rm = TRUE))
      true_subgroup_ahr[scenario, ] <- exp(apply(all_subgroups_log_ahr, 1, mean, na.rm = TRUE))
      
      if (scenario == "6") {
        true_ia_subgroup_hr[1, ] <- exp(apply(ia_subgroups_log_hr, 1, mean, na.rm = TRUE))
        true_ia_subgroup_ahr[1, ] <- exp(apply(ia_subgroups_log_ahr, 1, mean, na.rm = TRUE))
      }
    }
    
    # Save TTE Results
    simul_parameter <- list(
      true_overall_results = true_overall_results,
      true_subgroup_hr = true_subgroup_hr,
      true_subgroup_ahr = true_subgroup_ahr,
      true_ia_subgroup_hr = true_ia_subgroup_hr,
      true_ia_subgroup_ahr = true_ia_subgroup_ahr
    )
    save_file_tte <- file.path("TTE", "Scenarios", "truth.RData")
    save(simul_parameter, file = save_file_tte)
    message(paste("Saved TTE truth to:", save_file_tte))
    
  } else {
    
    # ========================================================
    # BRANCH B: BINARY / COUNT / CONTINUOUS (Empirical Truth)
    # ========================================================
    message(paste("ðŸš€ Calculating Empirical Truth for:", ep))
    
    # Setup Parameters
    metric_name <- switch(ep,
                          "binary" = "log_OR",
                          "count" = "log_RR",
                          "continuous" = "mean_diff")
    
    model_params <- .get_model_parameters(ep)
    # Important: Calculate huge N for simulation
    large_N <- model_params$N * inflation_factor 
    
    # Determine which subgroups to process
    # Use all subgroups (x_1 to x_10) to match data generation
    current_subgroups <- subgroup_names_short
    
    # Containers for results
    ep_overall_list <- list()
    ep_subgroup_list <- list()
    
    for (scen in all_scenarios) {
      message(paste("   ...Scenario", scen))
      
      # 1. Simulate LARGE Data
      # We call the internal helper directly to force large_N
      # We replicate this 'n_repetitions' times to smooth out MC error
      
      rep_overall <- numeric(n_repetitions)
      rep_subgroup <- matrix(NA, nrow = length(current_subgroups), ncol = n_repetitions)
      rownames(rep_subgroup) <- current_subgroups
      
      # Prepare scenario coefs once
      scen_coefs <- .get_scenario_coefs(scen, model_params)
      
      for(j in seq_len(n_repetitions)) {
        
        # Simulate ONE large dataset
        sim_df <- .simul_new_endpoint_single(
          n = large_N,
          endpoint = ep,
          model_params = model_params,
          coefs = scen_coefs,
          add_interaction = (scen == "6")
        )
        sim_df$arm <- factor(sim_df$arm) # Ensure factor for GLM
        
        # --- A. Overall Marginal Effect ---
        rep_overall[j] <- fit_marginal_model(sim_df, ep)
        
        # --- B. Subgroup Marginal Effects ---
        for(sg in current_subgroups) {
          # Parse subgroup string "x_1.a" -> var "x_1", level "a"
          filter_info <- get_subgroup_filter(sg)
          
          # Subset data
          # Note: columns in sim_df are like "x_1", "x_2", values are factors ("a", "b", etc)
          subset_df <- sim_df[sim_df[[filter_info$var]] == filter_info$lvl, ]
          
          if(nrow(subset_df) > 0) {
             rep_subgroup[sg, j] <- fit_marginal_model(subset_df, ep)
          }
        }
      }
      
      # 2. Aggregate Results (Mean over repetitions)
      avg_overall <- mean(rep_overall, na.rm = TRUE)
      avg_subgroup <- rowMeans(rep_subgroup, na.rm = TRUE)
      
      # 3. Store Overall Result
      ep_overall_list[[scen]] <- data.frame(
        scenario = scen,
        metric = metric_name,
        value = avg_overall,
        exp_value = ifelse(ep == "continuous", NA, exp(avg_overall))
      )
      
      # 4. Store Subgroup Results
      for(sg_name in names(avg_subgroup)) {
        val <- avg_subgroup[sg_name]
        ep_subgroup_list[[length(ep_subgroup_list) + 1]] <- data.frame(
          scenario = scen,
          subgroup = sg_name,
          metric = metric_name,
          value = val,
          exp_value = ifelse(ep == "continuous", NA, exp(val))
        )
      }
      
      # 5. Handle Scenario 6 Interactions (for non-TTE)
      if (scen == "6") {
        # Mimic the TTE logic: create x_1_2 interaction factor
        # and calculate truth for the 4 interaction subgroups
        message(paste("      ...Processing Scenario 6 interactions for", ep))
        
        rep_ia_subgroup <- matrix(NA, nrow = length(scen_6_subgroups), ncol = n_repetitions)
        rownames(rep_ia_subgroup) <- scen_6_subgroups
        
        for(j in seq_len(n_repetitions)) {
          # Re-simulate data for this repetition (same as above)
          sim_df <- .simul_new_endpoint_single(
            n = large_N,
            endpoint = ep,
            model_params = model_params,
            coefs = scen_coefs,
            add_interaction = TRUE  # Important: interaction is present in scenario 6
          )
          sim_df$arm <- factor(sim_df$arm)
          
          # Create x_1_2 interaction factor (mimics TTE logic)
          sim_df$x_1_2 <- factor(paste0(sim_df$x_1, sim_df$x_2))
          
          # For each of the 4 interaction subgroups
          for(ia_sg in scen_6_subgroups) {
            # Parse "x_1_2.aa" -> var "x_1_2", level "aa"
            filter_info <- get_subgroup_filter(ia_sg)
            
            # Subset to this interaction level
            subset_ia <- sim_df[sim_df[[filter_info$var]] == filter_info$lvl, ]
            
            # Check if both treatment arms are present
            if(nrow(subset_ia) > 0 && length(unique(subset_ia$arm)) == 2) {
              rep_ia_subgroup[ia_sg, j] <- fit_marginal_model(subset_ia, ep)
            }
          }
        }
        
        # Aggregate interaction results (mean over repetitions)
        avg_ia_subgroup <- rowMeans(rep_ia_subgroup, na.rm = TRUE)
        
        # Store interaction subgroup results
        for(ia_sg_name in names(avg_ia_subgroup)) {
          val <- avg_ia_subgroup[ia_sg_name]
          ep_subgroup_list[[length(ep_subgroup_list) + 1]] <- data.frame(
            scenario = scen,
            subgroup = ia_sg_name,
            metric = metric_name,
            value = val,
            exp_value = ifelse(ep == "continuous", NA, exp(val))
          )
        }
      }
    }
    
    # Combine results
    ep_truth_overall <- do.call(rbind, ep_overall_list)
    ep_truth_subgroup <- do.call(rbind, ep_subgroup_list)
    
    simul_truth <- list(
      truth_overall = ep_truth_overall,
      truth_subgroup = ep_truth_subgroup
    )
    
    # Save
    endpoint_folder <- switch(ep,
      "binary" = "Binary",
      "count" = "Count",
      "continuous" = "Continuous"
    )
    
    save_file_ep <- file.path(endpoint_folder, "Scenarios", "truth_2.RData")
    # Ensure dir exists
    if(!dir.exists(dirname(save_file_ep))) dir.create(dirname(save_file_ep), recursive = TRUE)
    
    save(simul_truth, file = save_file_ep)
    message(paste("Saved", ep, "truth (Empirical) to:", save_file_ep))
  }
}
```



---
title: "Detailed_functions_explanation_for_software_developers"
output: html_document
---

In this file I give a detailed explanation of the logic followed in the functions of the bonsaiforest2 library.

# File: prepare_formula_model.R
Purpose: Prepares a multi-part brms formula and modified data for downstream model fitting; 
Input: data, 
       response_formula_str, 
       shrunk_predictive_formula_str, 
       unshrunk_prognostic_formula_str, 
       unshrunk_predictive_formula_str,  
       shrunk_prognostic_formula_str, 
       response_type, 
       stratification_formula_str 
Returns: list(formula, data, response_type).

Start
|
v
prepare_formula_model(data, 
|                     response_formula_str, 
|                     'Optional predictive/prognostic formulas', 
|                     response_type)
|
+-- 1) Argument validation & parse initial formula
| - Calls: .parse_initial_formula(...)
| - Inputs: raw data, response_formula_str
| - Outputs: processed_data, response_term, offset_term, trt_var
| - Side-effects: finds names of trt, outcome and offset variables;
|                 converts trt_var to factor; sets treatment contrasts
|
v
Decision: response_type == "survival" ?

Yes:
| +-- 2a) Handle survival specifics
| - Calls: .handle_survival_response(response_term, 
|                                    processed_data,
|                                    stratification_formula_str)
| - Internals: parses Surv(...), converts to time | cens(1 - status), computes 
|              bhaz(...) args
| - Uses: .calculate_bhaz_knots(time_vector) to compute boundary_knots &
|          internal_knots
| - Output: updated response_term (possibly with bhaz(...)) or fallback to default
|           if knots NULL

No:
| +-- 2b) Optionally handle stratification for distributional params
| - Calls: .handle_distributional_stratification(response_type, 
|                                                stratification_formula_str,
|                                                data)
| - Output: sub_formulas list (e.g., sigma or shape brms::lf() objects)
|
v
+-- 3) Resolve term overlaps & defaults
| - Calls: .resolve_term_overlaps_and_defaults(unshrunk_prognostic_str,
|                                              shrunk_prognostic_str,
|                                              unshrunk_predictive_str,
|                                              shrunk_predictive_str, 
|                                              trt_var, 
|                                              data)
| - Output: cleaned lists: unshrunk_prog, shrunk_prog, unshrunk_pred, shrunk_pred
| - Ensures: treatment is added as prognostic if missing; removes overlaps
|
v
+-- 4) Process predictive terms (create explicit interaction dummies)
| - For shrunk predictive: .process_predictive_terms(shrunk_pred_str_full,
|                                                    processed_data, 
|                                                    trt_var)
| - For unshrunk predictive: .process_predictive_terms(unshrunk_pred_str_full,
|                                                      processed_data, 
|                                                      trt_var)
| - Outputs per call: formula_part (string of dummy names), updated data,
|                     prognostic_effects (main effects needed)
| - Key behavior:
| * Ensures trt_var factor has 2 levels
| * Converts subgroup vars to factor; sets contrasts for them
| * Creates explicit dummy columns like trt_subgroupLevel equal to 1 when (trt ==
|   treatment_level) & (subgroup == level) else 0
| * Returns formula fragment listing these dummies (e.g., "trt_subgroupA +
|   trt_subgroupB")
|
v
+-- 5) Auto-add missing prognostic main effects
| - Calls: .add_missing_prognostic_effects(prognostic_terms = c(unshrunk_prog, |   |                                                               shrunk_prog),
|                                          needed_terms = unique(prognostic_effects |                                                         from pred process),
|                                          target_term_list = unshrunk_prog)
| - Ensures hierarchical principle: any var used in trt:x has x in prognostic terms
|
v
+-- 6) Assemble final brms formula
| - Calls: .assemble_brms_formula(response_term, 
|                                 offset_term, 
|                                 response_type, 
|                                 unshrunk_prog_terms, 
|                                 shrunk_prog_terms, 
|                                 unshrunk_pred_formula, 
|                                 shrunk_pred_formula, 
|                                 sub_formulas)
| - Key steps:
| * Builds sub-formulas as brms::lf() for unprogeffect, shprogeffect, unpredeffect, |   shpredeffect
| * Applies intercept rules (has_intercept <- response_type != "survival")
| * Strips offset() wrapper and appends offset RHS if present
| * Creates main brms::bf(main_formula_str, nl = TRUE) and reduces with + to
|   include sub-formulas
|
v
Return

list(formula = final_bf_obj, data = processed_data, response_type = response_type)


### Key Details & Notes

- Treatment handling (.parse_initial_formula): Converts trt_var to factor if needed and sets contrasts via contr.sum(...) (treatment contrasts).

- Offset: offset(...) on LHS is detected and returned as offset_term; .assemble_brms_formula removes the offset() wrapper before including it in the RHS of the non-linear bf.

- Predictive dummy naming: uses make.names(paste0(.trt_var, "_", subgroup_var, level)) to ensure valid names; these are numeric 0/1 columns so each interaction yields a single parameter in non-linear brms setup.

- Hierarchical principle: predictive interactions auto-trigger addition of prognostic main effects; .add_missing_prognostic_effects appends missing main effects to unshrunk_prog with a message.

- Survival baseline hazard (bhaz) knots: .calculate_bhaz_knots uses unique event times, adds a small buffer to boundaries, chooses internal knots by quantiles if sufficient unique times exist, else evenly spaced fallback. If too few unique times (<4) it returns NULL and the code falls back to default Cox handling.

- Stratification: For response_type = "continuous", stratifies sigma; for "count", stratifies shape; for "survival" stratification triggers bhaz grouping via gr = strat_var.

- Overlap resolution rules: Prognostic overlap → prioritized as unshrunk (remove from shrunk); Predictive overlap → prioritized as shrunk (remove from unshrunk).

- Return contract: Use the returned data for brms::brm() because it contains factor conversions and created dummy columns required by the assembled formula.


###Quick mapping: major internal helpers
prepare_formula_model() → orchestrator

.parse_initial_formula() → extract response, offset, trt_var; convert trt factor/contrasts

.handle_survival_response() → transform Surv() and attach bhaz(...)

.calculate_bhaz_knots() → compute spline knots for bhaz

.handle_distributional_stratification() → create sigma/shape lf() sub-formulas

.resolve_term_overlaps_and_defaults() → parse & clean user formula strings, add trt default

.process_predictive_terms() → make explicit interaction dummies + return formula fragments

.add_missing_prognostic_effects() → ensure main effects for interactions

.assemble_brms_formula() → build brms::bf(..., nl=TRUE) and combine lf() parts


# File: fit_brms_model.R
Purpose: Wraps brms::brm() to fit the multi-part model produced by prepare_formula_model(), building and assigning appropriate priors (strings or brmsprior objects), handling family selection, and returning a brmsfit.
Input: prepared_model,
       predictive_effect_priors,
       prognostic_effect_priors,
       stanvars 
Returns: fitted `brmsfit` object.

Start
|
v
fit_brms_model(prepared_model, 
|              predictive_effect_priors, 
|              prognostic_effect_priors, 
|              stanvars, ...)
|
+-- 1) Argument validation & unpack
| - Validates prepared_model is a named list containing formula (class
|   brmsformula), data (data.frame), and response_type (one of 
|   "binary","count","continuous","survival")
| - Validates prior lists (predictive_effect_priors, prognostic_effect_priors) |     and stanvars
| - Unpacks: formula, data, response_type
|
v
+-- 2) Determine brms family
| - Maps response_type -> family:
|   * "continuous" -> gaussian()
|   * "binary" -> bernoulli(link = "logit")
|   * "count" -> negbinomial()
|   * "survival" -> cox()
| - Stops on invalid response_type
|
v
+-- 3) Construct prior configuration & process each prior target
| - Defines prior_config: a list of target records for
|   * shrunk prognostic (nlpar = "shprogeffect", default "horseshoe(1)")
|   * unshrunk prognostic (nlpar = "unprogeffect", default "normal(0,5)")
|   * prognostic intercept (nlpar = "unprogeffect", coef = "Intercept", default |     "normal(0,5)") — skipped for survival
|   * shrunk predictive (nlpar = "shpredeffect", default "horseshoe(1)")
|   * unshrunk predictive (nlpar = "unpredeffect", default "normal(0,10)")
| - Fetches which nlpars actually exist from names(formula$pforms)
| - For each configured target present in formula:
| - Calls .process_and_retarget_prior(user_prior, 
|                                     target_nlpar, 
|                                     default_str, 
|                                     target_class, 
|                                     target_coef)
| - Collects returned brmsprior objects in priors_list
| - Tracks which defaults were used to message the user
|
v
+-- 4) .process_and_retarget_prior() helper logic (see below)
|
v
+-- 5) Combine priors & prepare final prior object
| - If any priors were created: final_priors <- Reduce("+", priors_list)
| - Else: final_priors <- brms::empty_prior()
| - Prints message listing defaults used (if any)
|
v
+-- 6) Call brms::brm()
| - Arguments: formula, 
|              data, 
|              family = model_family, 
|              prior = final_priors,
|              stanvars, ... (other brm args)
| - Returns fitted brmsfit object
|
v
Return brmsfit

### Key Details & Notes

- Validation and safety: Uses checkmate to assert structure and types for prepared_model, prior lists, and stanvars. Requires prepared_model$formula be a brmsformula and prepared_model$data a non-empty data.frame.

- Family mapping: A simple switch() maps response_type to brms family constructors; invalid types error out.

- Prior configuration: The code only applies priors to nlpars present in formula$pforms (so unused components are ignored). Intercept prior is skipped for response_type == "survival" because survival non-linear parts have no intercept. Defaults are used when user does not provide a prior for a target; defaults are logged via message.

- Prior processing behavior (.process_and_retarget_prior):
Accepts user_prior that may be:
 * NULL → function uses default_str and flags default_used = TRUE.
 * character string → wraps into a brmsprior via brms::set_prior(prior = "...",    nlpar = target_nlpar, [class], [coef]).
 * brmsprior object → retargets rows with empty nlpar to the target_nlpar and   
   (optionally) sets class and coef columns for those rows; logs an informative    message about retargeting. 

If user_prior is a brmsprior, the helper only modifies rows where nlpar is blank (so already-targeted priors remain untouched).
The helper returns a list: list(prior = <brmsprior>, default_used = <TRUE/FALSE>).
If user_prior is none of the accepted types, it errors.
Combining priors:
priors_list elements are combined with Reduce("+", priors_list) to produce a single brmsprior object accepted by brms::brm().
If no priors defined, brms::empty_prior() is used.

- stanvars support: stanvars (class stanvars) are accepted and forwarded to brms::brm() unchanged, enabling custom Stan code inclusion.

- ... passthrough: All extra arguments are forwarded to brms::brm(), so the caller controls sampling parameters (chains, iter, warmup, backend, etc.).

- Messaging: The function emits messages listing default priors that were used and retargeting actions when brmsprior objects are adjusted.

- Return value: Returns the brmsfit object returned by brms::brm() for downstream use (posterior prediction, diagnostics, etc.).

### Quick mapping: major internal helper

fit_brms_model() → orchestrator; validates input, chooses family, builds priors, calls brms::brm()

.process_and_retarget_prior() → converts/retargets user-specified priors; returns brmsprior + flag indicating if default was used

# File: run_brms_analysis.R
Purpose: High-level user-facing wrapper that prepares formula/data via prepare_formula_model() and fits the model via fit_brms_model(), returning a brmsfit.
Input: data, 
       response_formula_str, 
       shrunk_predictive_formula_str, 
       unshrunk_prognostic_formula_str, 
       unshrunk_predictive_formula_str,  
       shrunk_prognostic_formula_str, 
       response_type, 
       stratification_formula_str, 
       predictive_effect_priors,
       prognostic_effect_priors,
       stanvars 
Returns: fitted `brmsfit` object.

Start
|
v
run_brms_analysis(data, 
|                 response_formula_str, 
|                 response_type, ..., 
|                 prognostic_effect_priors, 
|                 predictive_effect_priors,
|                 stanvars, ...)
|
+-- 1) Prepare formula & data
| - Calls: prepare_formula_model(data, 
|                                response_formula_str,
|                                shrunk_predictive_formula_str,
|                                unshrunk_prognostic_formula_str, 
|                                unshrunk_predictive_formula_str,
|                                shrunk_prognostic_formula_str, 
|                                response_type, 
|                                stratification_formula_str)
| - Side-effects / outputs:
| - Messages: "Step 1: Preparing formula and data..."
| - Returns prepared_model (list with formula, data, response_type)
|
v
+-- 2) Fit the Bayesian model
| - Messages: "Step 2: Fitting the brms model..."
| - Calls: fit_brms_model(prepared_model = prepared_model,
|                         predictive_effect_priors = predictive_effect_priors,
|                         prognostic_effect_priors = prognostic_effect_priors, 
|                         stanvars = stanvars, ...)
| - Passes through user ... args (chains, iter, cores, backend, etc.)
| - fit_brms_model() handles validation, family selection, prior construction, and brms::brm() call
|
v
+-- 3) Return final model
| - Messages: "Analysis complete."
| - Returns: fitted brmsfit object from fit_brms_model()
|
v
End

### Key Details & Notes

- run_brms_analysis() is a thin orchestrator: it does not validate priors itself; it delegates data/formula prep to prepare_formula_model() and prior handling + fitting to fit_brms_model().

- Defaults: predictive_effect_priors and prognostic_effect_priors default to empty lists; fit_brms_model() will apply defaults where needed and message which defaults were used.

-Passthrough: All additional arguments in ... are forwarded to fit_brms_model() and ultimately to brms::brm(), giving callers full control over sampling and performance options.

- Messages: The function prints three concise progress messages to help track the run steps.

- Return contract: Always returns the brmsfit object produced by fit_brms_model(); callers should inspect/validate convergence and diagnostics themselves.

###Quick mapping: major collaborators
run_brms_analysis() → orchestrator/wrapper

prepare_formula_model() → builds multi-part brmsformula, prepares/encodes data

fit_brms_model() → validates prepared object, constructs priors, calls brms::brm(), returns brmsfit


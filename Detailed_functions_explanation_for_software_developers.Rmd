---
title: "Detailed_functions_explanation_for_software_developers"
output: html_document
---

In this file I give a detailed explanation of the logic followed in the functions of the bonsaiforest2 library.

# File: prepare_formula_model.R
Purpose: Prepares a multi-part brms formula and modified data for downstream model fitting; 
Input: data, 
       response_formula_str, 
       shrunk_predictive_formula_str, 
       unshrunk_prognostic_formula_str, 
       unshrunk_predictive_formula_str,  
       shrunk_prognostic_formula_str, 
       response_type, 
       stratification_formula_str 
Returns: list(formula, data, response_type).

Start
|
v
prepare_formula_model(data, 
|                     response_formula_str, 
|                     'Optional predictive/prognostic formulas', 
|                     response_type)
|
+-- 1) Argument validation & parse initial formula
| - Calls: .parse_initial_formula(...)
| - Inputs: raw data, response_formula_str
| - Outputs: processed_data, response_term, offset_term, trt_var
| - Side-effects: finds names of trt, outcome and offset variables;
|                 converts trt_var to factor; sets treatment contrasts
|
v
Decision: response_type == "survival" ?

Yes:
| +-- 2a) Handle survival specifics
| - Calls: .handle_survival_response(response_term, 
|                                    processed_data,
|                                    stratification_formula_str)
| - Internals: parses Surv(...), converts to time | cens(1 - status), computes 
|              bhaz(...) args
| - Uses: .calculate_bhaz_knots(time_vector) to compute boundary_knots &
|          internal_knots
| - Output: updated response_term (possibly with bhaz(...)) or fallback to default
|           if knots NULL

No:
| +-- 2b) Optionally handle stratification for distributional params
| - Calls: .handle_distributional_stratification(response_type, 
|                                                stratification_formula_str,
|                                                data)
| - Output: sub_formulas list (e.g., sigma or shape brms::lf() objects)
|
v
+-- 3) Resolve term overlaps & defaults
| - Calls: .resolve_term_overlaps_and_defaults(unshrunk_prognostic_str,
|                                              shrunk_prognostic_str,
|                                              unshrunk_predictive_str,
|                                              shrunk_predictive_str, 
|                                              trt_var, 
|                                              data)
| - Output: cleaned lists: unshrunk_prog, shrunk_prog, unshrunk_pred, shrunk_pred
| - Ensures: treatment is added as prognostic if missing; removes overlaps
|
v
+-- 4) Process predictive terms (create explicit interaction dummies)
| - For shrunk predictive: .process_predictive_terms(shrunk_pred_str_full,
|                                                    processed_data, 
|                                                    trt_var)
| - For unshrunk predictive: .process_predictive_terms(unshrunk_pred_str_full,
|                                                      processed_data, 
|                                                      trt_var)
| - Outputs per call: formula_part (string of dummy names), updated data,
|                     prognostic_effects (main effects needed)
| - Key behavior:
| * Ensures trt_var factor has 2 levels
| * Converts subgroup vars to factor; sets contrasts for them
| * Creates explicit dummy columns like trt_subgroupLevel equal to 1 when (trt ==
|   treatment_level) & (subgroup == level) else 0
| * Returns formula fragment listing these dummies (e.g., "trt_subgroupA +
|   trt_subgroupB")
|
v
+-- 5) Auto-add missing prognostic main effects
| - Calls: .add_missing_prognostic_effects(prognostic_terms = c(unshrunk_prog, |   |                                                               shrunk_prog),
|                                          needed_terms = unique(prognostic_effects |                                                         from pred process),
|                                          target_term_list = unshrunk_prog)
| - Ensures hierarchical principle: any var used in trt:x has x in prognostic terms
|
v
+-- 6) Assemble final brms formula
| - Calls: .assemble_brms_formula(response_term, 
|                                 offset_term, 
|                                 response_type, 
|                                 unshrunk_prog_terms, 
|                                 shrunk_prog_terms, 
|                                 unshrunk_pred_formula, 
|                                 shrunk_pred_formula, 
|                                 sub_formulas)
| - Key steps:
| * Builds sub-formulas as brms::lf() for unprogeffect, shprogeffect, unpredeffect, |   shpredeffect
| * Applies intercept rules (has_intercept <- response_type != "survival")
| * Strips offset() wrapper and appends offset RHS if present
| * Creates main brms::bf(main_formula_str, nl = TRUE) and reduces with + to
|   include sub-formulas
|
v
Return

list(formula = final_bf_obj, data = processed_data, response_type = response_type)


### Key Details & Notes

- Treatment handling (.parse_initial_formula): Converts trt_var to factor if needed and sets contrasts via contr.sum(...) (treatment contrasts).

- Offset: offset(...) on LHS is detected and returned as offset_term; .assemble_brms_formula removes the offset() wrapper before including it in the RHS of the non-linear bf.

- Predictive dummy naming: uses make.names(paste0(.trt_var, "_", subgroup_var, level)) to ensure valid names; these are numeric 0/1 columns so each interaction yields a single parameter in non-linear brms setup.

- Hierarchical principle: predictive interactions auto-trigger addition of prognostic main effects; .add_missing_prognostic_effects appends missing main effects to unshrunk_prog with a message.

- Survival baseline hazard (bhaz) knots: .calculate_bhaz_knots uses unique event times, adds a small buffer to boundaries, chooses internal knots by quantiles if sufficient unique times exist, else evenly spaced fallback. If too few unique times (<4) it returns NULL and the code falls back to default Cox handling.

- Stratification: For response_type = "continuous", stratifies sigma; for "count", stratifies shape; for "survival" stratification triggers bhaz grouping via gr = strat_var.

- Overlap resolution rules: Prognostic overlap → prioritized as unshrunk (remove from shrunk); Predictive overlap → prioritized as shrunk (remove from unshrunk).

- Return contract: Use the returned data for brms::brm() because it contains factor conversions and created dummy columns required by the assembled formula.


###Quick mapping: major internal helpers
prepare_formula_model() → orchestrator

.parse_initial_formula() → extract response, offset, trt_var; convert trt factor/contrasts

.handle_survival_response() → transform Surv() and attach bhaz(...)

.calculate_bhaz_knots() → compute spline knots for bhaz

.handle_distributional_stratification() → create sigma/shape lf() sub-formulas

.resolve_term_overlaps_and_defaults() → parse & clean user formula strings, add trt default

.process_predictive_terms() → make explicit interaction dummies + return formula fragments

.add_missing_prognostic_effects() → ensure main effects for interactions

.assemble_brms_formula() → build brms::bf(..., nl=TRUE) and combine lf() parts


# File: fit_brms_model.R
Purpose: Wraps brms::brm() to fit the multi-part model produced by prepare_formula_model(), building and assigning appropriate priors (strings or brmsprior objects), handling family selection, and returning a brmsfit.
Input: prepared_model,
       predictive_effect_priors,
       prognostic_effect_priors,
       stanvars 
Returns: fitted `brmsfit` object.

Start
|
v
fit_brms_model(prepared_model, 
|              predictive_effect_priors, 
|              prognostic_effect_priors, 
|              stanvars, ...)
|
+-- 1) Argument validation & unpack
| - Validates prepared_model is a named list containing formula (class
|   brmsformula), data (data.frame), and response_type (one of 
|   "binary","count","continuous","survival")
| - Validates prior lists (predictive_effect_priors, prognostic_effect_priors) |     and stanvars
| - Unpacks: formula, data, response_type
|
v
+-- 2) Determine brms family
| - Maps response_type -> family:
|   * "continuous" -> gaussian()
|   * "binary" -> bernoulli(link = "logit")
|   * "count" -> negbinomial()
|   * "survival" -> cox()
| - Stops on invalid response_type
|
v
+-- 3) Construct prior configuration & process each prior target
| - Defines prior_config: a list of target records for
|   * shrunk prognostic (nlpar = "shprogeffect", default "horseshoe(1)")
|   * unshrunk prognostic (nlpar = "unprogeffect", default "normal(0,5)")
|   * prognostic intercept (nlpar = "unprogeffect", coef = "Intercept", default |     "normal(0,5)") — skipped for survival
|   * shrunk predictive (nlpar = "shpredeffect", default "horseshoe(1)")
|   * unshrunk predictive (nlpar = "unpredeffect", default "normal(0,10)")
| - Fetches which nlpars actually exist from names(formula$pforms)
| - For each configured target present in formula:
| - Calls .process_and_retarget_prior(user_prior, 
|                                     target_nlpar, 
|                                     default_str, 
|                                     target_class, 
|                                     target_coef)
| - Collects returned brmsprior objects in priors_list
| - Tracks which defaults were used to message the user
|
v
+-- 4) .process_and_retarget_prior() helper logic (see below)
|
v
+-- 5) Combine priors & prepare final prior object
| - If any priors were created: final_priors <- Reduce("+", priors_list)
| - Else: final_priors <- brms::empty_prior()
| - Prints message listing defaults used (if any)
|
v
+-- 6) Call brms::brm()
| - Arguments: formula, 
|              data, 
|              family = model_family, 
|              prior = final_priors,
|              stanvars, ... (other brm args)
| - Returns fitted brmsfit object
|
v
Return brmsfit

### Key Details & Notes

- Validation and safety: Uses checkmate to assert structure and types for prepared_model, prior lists, and stanvars. Requires prepared_model$formula be a brmsformula and prepared_model$data a non-empty data.frame.

- Family mapping: A simple switch() maps response_type to brms family constructors; invalid types error out.

- Prior configuration: The code only applies priors to nlpars present in formula$pforms (so unused components are ignored). Intercept prior is skipped for response_type == "survival" because survival non-linear parts have no intercept. Defaults are used when user does not provide a prior for a target; defaults are logged via message.

- Prior processing behavior (.process_and_retarget_prior):
Accepts user_prior that may be:
 * NULL → function uses default_str and flags default_used = TRUE.
 * character string → wraps into a brmsprior via brms::set_prior(prior = "...",    nlpar = target_nlpar, [class], [coef]).
 * brmsprior object → retargets rows with empty nlpar to the target_nlpar and   
   (optionally) sets class and coef columns for those rows; logs an informative    message about retargeting. 

If user_prior is a brmsprior, the helper only modifies rows where nlpar is blank (so already-targeted priors remain untouched).
The helper returns a list: list(prior = <brmsprior>, default_used = <TRUE/FALSE>).
If user_prior is none of the accepted types, it errors.
Combining priors:
priors_list elements are combined with Reduce("+", priors_list) to produce a single brmsprior object accepted by brms::brm().
If no priors defined, brms::empty_prior() is used.

- stanvars support: stanvars (class stanvars) are accepted and forwarded to brms::brm() unchanged, enabling custom Stan code inclusion.

- ... passthrough: All extra arguments are forwarded to brms::brm(), so the caller controls sampling parameters (chains, iter, warmup, backend, etc.).

- Messaging: The function emits messages listing default priors that were used and retargeting actions when brmsprior objects are adjusted.

- Return value: Returns the brmsfit object returned by brms::brm() for downstream use (posterior prediction, diagnostics, etc.).

### Quick mapping: major internal helper

fit_brms_model() → orchestrator; validates input, chooses family, builds priors, calls brms::brm()

.process_and_retarget_prior() → converts/retargets user-specified priors; returns brmsprior + flag indicating if default was used

# File: run_brms_analysis.R
Purpose: High-level user-facing wrapper that prepares formula/data via prepare_formula_model() and fits the model via fit_brms_model(), returning a brmsfit.
Input: data, 
       response_formula_str, 
       shrunk_predictive_formula_str, 
       unshrunk_prognostic_formula_str, 
       unshrunk_predictive_formula_str,  
       shrunk_prognostic_formula_str, 
       response_type, 
       stratification_formula_str, 
       predictive_effect_priors,
       prognostic_effect_priors,
       stanvars 
Returns: fitted `brmsfit` object.

Start
|
v
run_brms_analysis(data, 
|                 response_formula_str, 
|                 response_type, ..., 
|                 prognostic_effect_priors, 
|                 predictive_effect_priors,
|                 stanvars, ...)
|
+-- 1) Prepare formula & data
| - Calls: prepare_formula_model(data, 
|                                response_formula_str,
|                                shrunk_predictive_formula_str,
|                                unshrunk_prognostic_formula_str, 
|                                unshrunk_predictive_formula_str,
|                                shrunk_prognostic_formula_str, 
|                                response_type, 
|                                stratification_formula_str)
| - Side-effects / outputs:
| - Messages: "Step 1: Preparing formula and data..."
| - Returns prepared_model (list with formula, data, response_type)
|
v
+-- 2) Fit the Bayesian model
| - Messages: "Step 2: Fitting the brms model..."
| - Calls: fit_brms_model(prepared_model = prepared_model,
|                         predictive_effect_priors = predictive_effect_priors,
|                         prognostic_effect_priors = prognostic_effect_priors, 
|                         stanvars = stanvars, ...)
| - Passes through user ... args (chains, iter, cores, backend, etc.)
| - fit_brms_model() handles validation, family selection, prior construction, and brms::brm() call
|
v
+-- 3) Return final model
| - Messages: "Analysis complete."
| - Returns: fitted brmsfit object from fit_brms_model()
|
v
End

### Key Details & Notes

- run_brms_analysis() is a thin orchestrator: it does not validate priors itself; it delegates data/formula prep to prepare_formula_model() and prior handling + fitting to fit_brms_model().

- Defaults: predictive_effect_priors and prognostic_effect_priors default to empty lists; fit_brms_model() will apply defaults where needed and message which defaults were used.

-Passthrough: All additional arguments in ... are forwarded to fit_brms_model() and ultimately to brms::brm(), giving callers full control over sampling and performance options.

- Messages: The function prints three concise progress messages to help track the run steps.

- Return contract: Always returns the brmsfit object produced by fit_brms_model(); callers should inspect/validate convergence and diagnostics themselves.

###Quick mapping: major collaborators
run_brms_analysis() → orchestrator/wrapper

prepare_formula_model() → builds multi-part brmsformula, prepares/encodes data

fit_brms_model() → validates prepared object, constructs priors, calls brms::brm(), returns brmsfit

# File: estimate_subgroup_effects.R
Purpose: Post-processing function that estimates marginal subgroup treatment effects from a fitted brmsfit object using a counterfactual, G-computation approach.
Input: brms_fit,
       original_data,
       trt_var,
       subgroup_vars,
       response_type,
       ndraws
Returns: list(estimates = data.frame with marginal effects per subgroup, draws = data.frame with posterior draws).

Start
|
v
estimate_subgroup_effects(brms_fit,
|                         original_data,
|                         trt_var,
|                         subgroup_vars = "auto",
|                         response_type,
|                         ndraws = NULL)
|
+-- 1) Validate inputs and extract model data
| - Assertions: brms_fit is brmsfit, original_data is data.frame, trt_var exists
| - Check response_type is valid: "continuous", "binary", "count", or "survival"
| - Extract model_data from brms_fit$data (contains factor levels & contrasts used in fitting)
| - Warning: if row count differs between original_data and brms_fit$data
|
v
+-- 2) Prepare subgroup variables and determine which to analyze
| - Calls: .prepare_subgroup_vars(brms_fit, original_data, trt_var, subgroup_vars)
| - If subgroup_vars == "auto": 
|   * Scans model_data for interaction dummy columns (pattern: trt_var_...)
|   * Infers which factor variables were used in interactions
|   * If no interactions found: sets is_overall = TRUE, subgroup_vars = "Overall"
| - Else: validates user-provided subgroup_vars exist in original_data
| - Output: prep list with (subgroup_vars, data [possibly with "Overall" added], is_overall)
|
v
+-- 3) Create counterfactual datasets
| - Calls: .create_counterfactual_datasets(prep$data, trt_var)
| - Creates two identical datasets (treatment and control):
|   * All rows set to reference level (control) or active level (treatment)
|   * Recreates explicit interaction dummy columns (trt_var_...) for treatment arm
|   * Interaction dummies = 1 when: patient in subgroup level AND treatment = active
|   * Otherwise 0 in both counterfactuals
| - Output: counterfactual_data list with (control, treatment) datasets
|
v
+-- 4) Generate posterior predictions
| - Calls: .get_posterior_predictions(brms_fit, data_control, data_treatment, 
|                                     response_type, prep$data, ndraws)
| - Decision: response_type == "survival" ?
| 
| Yes:
| | - Extracts linear predictors (eta) for both counterfactuals via posterior_linpred()
| | - Reconstructs baseline hazard posterior:
| | | - Calls: .extract_baseline_hazard(brms_fit, prep$data, ndraws)
| | | - Parses formula for Surv(time, status) structure & stratification var
| | | - Rebuilds spline basis (iSpline) for baseline hazard evaluation
| | | - Returns H0_posterior (list, possibly stratified), strat_var
| | - Output: list(H0_posterior, linpred_control, linpred_treatment, strat_var, original_data)
| 
| No:
| | - Gets expected outcomes via posterior_epred() for both counterfactuals
| | - Handles memory efficiently: combines datasets, makes single call, splits results
| | - Output: list(pred_control [matrix: draws x observations], 
| |                pred_treatment [matrix: draws x observations])
|
v
+-- 5) Calculate marginal effects per subgroup & summarize
| - Calls: .calculate_and_summarize_effects(posterior_preds, prep$data, 
|                                           prep$subgroup_vars, prep$is_overall, 
|                                           response_type)
| - For each subgroup variable:
|   * For each level in that subgroup:
|     - Gets indices of observations belonging to that level
|     - Decision: response_type == "survival" ?
|     
|     Yes:
|     | - Calls: .calculate_survival_ahr_draws(linpred_control, linpred_treatment,
|     |                                         H0_posterior_list, indices, 
|     |                                         strat_var, original_data)
|     | - For each posterior draw (chunked for memory efficiency):
|     |   * Reconstructs marginal survival curves for subgroup via .get_marginal_survival_vectorized()
|     |     - Applies linear predictors to baseline hazard: S(t) = exp(-H0(t) * exp(eta))
|     |     - Averages survival curves across individuals in subgroup for each draw
|     |   * Computes Average Hazard Ratio (AHR) from marginal curves via .calculate_ahr_vectorized()
|     |     - AHR = sum(S_control * dS_treatment) / sum(S_treatment * dS_control)
|     | - Returns: vector of AHR draws (one per posterior draw)
|     
|     No:
|     | - Extracts predictions for subgroup individuals
|     | - Computes marginal (averaged) effect per draw: difference or ratio
|     | - For continuous/binary: effect = mean(pred_treatment) - mean(pred_control)
|     | - For count: effect = mean(pred_treatment) / mean(pred_control)
|     | - Returns: vector of effect draws
|     
|     - Summarizes draws: median & 95% credible interval (q2.5, q97.5)
|     - Creates result tibble row with: subgroup, effect, mean, sd, q2.5, q97.5
|
v
+-- 6) Combine and return results
| - Binds all subgroup result rows into final estimates tibble
| - Binds all effect draws into draws data.frame (columns = subgroups)
| - Returns: list(estimates, draws)
|
v
End

### Key Details & Notes

- Data consistency: Uses brms_fit$data (with factor contrasts) rather than original_data for all internal operations, ensuring predictions align with model's encoding.

- Counterfactual principle: Both treatment and control datasets have all other covariates unchanged; only treatment assignment and related interaction dummies differ. This enables G-computation (marginal effect) via averaging.

- Auto-detection of subgroups: Searches for explicit interaction dummy columns created by prepare_formula_model() (pattern: trt_var_levelname); if none found, computes overall marginal effect.

- Survival AHR calculation: Uses reconstructed spline-based baseline hazard to compute marginal survival curves, then derives hazard ratios. Handles stratified hazards (separate baseline per stratum).

- Memory efficiency: 
  * For non-survival: combines control/treatment in single posterior_epred() call
  * For survival: chunks AHR calculations to avoid storing all draws × all individuals simultaneously

- Posterior draw processing: If ndraws specified, subsamples from posterior; otherwise uses all available draws for inference.

- Effect computation: 
  * Continuous/binary: difference in marginal outcomes
  * Count: ratio of marginal means
  * Survival: average hazard ratio from marginal survival curves

- Output structure: Returns both point estimates (median ± 95% CI) and full posterior draws for downstream visualization/inference.

### Quick mapping: major internal helpers

estimate_subgroup_effects() → orchestrator; validates inputs, coordinates 4-step process

.prepare_subgroup_vars() → auto-detects or validates subgroup variables from model interaction structure

.create_counterfactual_datasets() → builds all-treated and all-control datasets with interaction dummies

.get_posterior_predictions() → dispatches to posterior_linpred (survival) or posterior_epred (other) with appropriate data handling

.extract_baseline_hazard() → reconstructs spline basis & evaluates baseline hazard posterior from fitted model

.get_marginal_survival_vectorized() → computes marginal survival curves by averaging over subgroup individuals

.calculate_survival_ahr_draws() → per-draw average hazard ratio from marginal survival curves (chunked for memory)

.calculate_ahr_vectorized() → converts survival probability matrices to hazard ratio per draw

.calculate_and_summarize_effects() → computes marginal effects per subgroup, summarizes with posterior statistics

# File: summary_subgroup_effects.R
Purpose: High-level wrapper that creates a formatted summary object from marginal subgroup treatment effects and provides a forest plot visualization.
Input (summary_subgroup_effects): brms_fit,
                                  original_data,
                                  trt_var,
                                  response_type,
                                  subgroup_vars
Input (plot.subgroup_summary): x (subgroup_summary object),
                               x_lab (optional),
                               title (optional)
Returns (summary_subgroup_effects): list with class "subgroup_summary"
Returns (plot.subgroup_summary): ggplot object (forest plot).

## Part 1: summary_subgroup_effects()

Start
|
v
summary_subgroup_effects(brms_fit,
|                        original_data,
|                        trt_var,
|                        response_type,
|                        subgroup_vars = "auto")
|
+-- 1) Validate all inputs
| - Assertions: brms_fit is brmsfit, original_data is data.frame, trt_var exists
| - Check response_type is valid: "binary", "count", "continuous", or "survival"
| - Validate subgroup_vars: must be "auto" OR character vector (cannot be NULL)
| - If subgroup_vars is character vector: assert all names exist in original_data
|
v
+-- 2) Call estimate_subgroup_effects()
| - Passes: brms_fit, original_data, trt_var, subgroup_vars, response_type
| - Returns: list with (estimates = tibble, draws = data.frame)
| - Assigns estimates_tbl for downstream use
|
v
+-- 3) Construct summary_subgroup_effects object
| - Creates list with components:
|   * estimates: tibble from estimate_subgroup_effects()
|   * response_type: passed through for plot defaults
|   * ci_level: fixed at 0.95 (95% credible interval)
|   * trt_var: treatment variable name (metadata)
| - Assigns class "subgroup_summary" for S3 dispatch
|
v
Return list(estimates, response_type, ci_level, trt_var) with class "subgroup_summary"

## Part 2: plot.subgroup_summary() [S3 method]

Start
|
v
plot.subgroup_summary(x,
|                     x_lab = NULL,
|                     title = NULL,
|                     ...)
|
+-- 1) Validate inputs
| - Assert x is class "subgroup_summary"
| - Assert x_lab is character string or NULL
| - Assert title is character string or NULL
| - Assert x$estimates is non-empty data.frame
|
v
+-- 2) Determine plot parameters based on response_type
| - null_effect_line (x-intercept value):
|   * continuous → 0 (no difference)
|   * binary → 1 (odds ratio = 1)
|   * count → 1 (rate ratio = 1)
|   * survival → 1 (average hazard ratio = 1)
| - Default x_lab if not provided:
|   * continuous → "Difference in Mean Outcome"
|   * binary → "Odds Ratio"
|   * count → "Rate Ratio"
|   * survival → "Average Hazard Ratio (AHR)"
|
v
+-- 3) Prepare plot data
| - Creates estimate_label: formatted string "%.2f (%.2f to %.2f)"
| - Extracts sort_group: first component before ":" in Subgroup name
| - Sorts by sort_group then Subgroup alphabetically
| - Converts Subgroup to factor with reversed level order (for correct y-axis orientation)
|
v
+-- 4) Calculate plot limits and text positioning
| - Finds min(CI_Lower), max(CI_Upper) across all subgroups
| - Computes x_range = max_ci - min_ci
| - Sets pos_estimate = max_ci + (x_range * 0.15) for label placement
|
v
+-- 5) Build ggplot2 visualization
| - Layer 1: geom_vline at null_effect_line (dashed, grey50)
| - Layer 2: geom_errorbar for confidence intervals (y-oriented, width = 0.2)
| - Layer 3: geom_point for point estimates (shape = 22, size = 3, black)
| - Layer 4: geom_text for estimate labels right-aligned at pos_estimate
| - Layer 5: annotate() for column header "Estimate (95% CI)"
| - Axes: x = response-specific label, y = blank (uses subgroup names)
| - Theme: classic base (12pt), centered bold title, clean y-axis (no ticks/lines)
| - Margins: enlarged right margin (8 lines) for label space
| - Clipping: turned off (clip = "off") to allow labels outside plot area
|
v
Return ggplot object (forest plot)

### Key Details & Notes

- Two-function pattern: summary_subgroup_effects() orchestrates effect estimation and creates the S3 object; plot.subgroup_summary() provides forest plot visualization via S3 dispatch.

- Input validation: subgroup_vars must be "auto" or explicit character vector (never NULL); ensures user intent is clear.

- Metadata storage: response_type, ci_level, and trt_var are stored in the summary object for consistent plot defaults and transparency.

- Null effect line: Automatically placed at response-type-specific value (0 for difference, 1 for ratio-based effects).

- Sorting logic: Subgroups are sorted by variable name first (sort_group), then by level within each variable, enabling readable grouped display.

- Spatial arrangement: Uses y-axis labels for subgroup names and positions estimate text at x = pos_estimate (15% beyond max CI) to avoid overlap with error bars.

- ggplot2 construction: Purposefully disables y-axis ticks and lines (theme), reverses factor levels for correct orientation, and uses coord_cartesian(clip = "off") to display labels outside plotting area.

- Label formatting: Median estimate and 95% CI displayed as "value (lower to upper)" with 2 decimal places for readability.

### Quick mapping: major collaborators

summary_subgroup_effects() → orchestrator; validates inputs, delegates effect estimation, returns S3 object

estimate_subgroup_effects() → computes marginal effects per subgroup, returns estimates + draws

plot.subgroup_summary() → S3 method; transforms summary object into forest plot via ggplot2

